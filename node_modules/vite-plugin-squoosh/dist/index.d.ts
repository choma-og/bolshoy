import { Plugin } from 'vite';

interface SharedEncoderOptions {
    quality?: number;
}
interface Encoder {
    extension?: RegExp;
}
interface ProgressiveEncoderOptions {
    progressive?: boolean;
}
interface EffortEncoderOptions {
    effort?: number;
}
interface MozJPEGEncodeOptions extends SharedEncoderOptions, ProgressiveEncoderOptions, Encoder {
    baseline?: boolean;
    arithmetic?: boolean;
    optimize_coding?: boolean;
    smoothing?: number;
    color_space?: number;
    trellis_multipass?: boolean;
    trellis_opt_zero?: boolean;
    trellis_opt_table?: boolean;
    trellis_loops?: number;
    auto_subsample?: boolean;
    chroma_subsample?: number;
    separate_chroma_quality?: boolean;
    chroma_quality?: number;
    quant_table?: number;
}
interface WebPEncodeOptions extends SharedEncoderOptions, Encoder {
    target_size?: number;
    target_PSNR?: number;
    method?: number;
    sns_strength?: number;
    filter_strength?: number;
    filter_sharpness?: number;
    filter_type?: number;
    partitions?: number;
    segments?: number;
    pass?: number;
    show_compressed?: number;
    preprocessing?: number;
    autofilter?: number;
    partition_limit?: number;
    alpha_compression?: number;
    alpha_filtering?: number;
    alpha_quality?: number;
    lossless?: number;
    exact?: number;
    image_hint?: number;
    emulate_jpeg_size?: number;
    thread_level?: number;
    low_memory?: number;
    near_lossless?: number;
    use_delta_palette?: number;
    use_sharp_yuv?: number;
}
interface AvifEncodeOptions extends Encoder {
    cqLevel?: number;
    cqAlphaLevel?: number;
    denoiseLevel?: number;
    tileColsLog2?: number;
    tileRowsLog2?: number;
    speed?: number;
    subsample?: number;
    chromaDeltaQ?: boolean;
    sharpness?: number;
    tune?: number;
}
interface JxlEncodeOptions extends SharedEncoderOptions, ProgressiveEncoderOptions, EffortEncoderOptions, Encoder {
    epf?: number;
    lossyPalette?: boolean;
    decodingSpeedTier?: number;
    photonNoiseIso?: number;
    lossyModular?: boolean;
}
interface WebP2EncodeOptions extends SharedEncoderOptions, EffortEncoderOptions, Encoder {
    alpha_quality?: number;
    pass?: number;
    sns?: number;
    uv_mode?: number;
    csp_type?: number;
    error_diffusion?: number;
    use_random_matrix?: boolean;
}
interface OxiPNGEncodeOptions extends Encoder {
    level?: number;
}
interface EncoderOptions {
    mozjpeg?: MozJPEGEncodeOptions;
    webp?: WebPEncodeOptions;
    avif?: AvifEncodeOptions;
    jxl?: JxlEncodeOptions;
    wp2?: WebP2EncodeOptions;
    oxipng?: OxiPNGEncodeOptions;
}
type EncoderType = "mozjpeg" | "webp" | "avif" | "jxl" | "wp2" | "oxipng";

type CacheLevel = "None" | "PerSession" | "Persistent";
interface FromTo<T> {
    from: T;
    to: T;
}

interface ModuleOptions {
    /**
     * @see {@link https://github.com/GoogleChromeLabs/squoosh/blob/dev/libsquoosh/src/codecs.ts}
     */
    codecs?: EncoderOptions;
    /**
     * Enable/disable logging.
     * @default: false
     */
    silent?: boolean;
    /**
     * File names or extensions to exclude.
     * @example
     * // Exclude all webp and wp2 extensions.
     * { exclude: /.(webp|wp2)$/}
     */
    exclude?: RegExp;
    /**
     * Specify what certain file names or extensions will encode to.
     */
    encodeTo?: {
        from: RegExp;
        to: EncoderType;
    }[];
    /**
     * Additional directories to include. **WARNING!** These images will be replaced with their encoded versions.
     */
    includeDirs?: string[] | FromTo<string>[];
    /**
     * Toggle asset caching. When enabled, encoded assets will be reused.
     * @default: "None"
     */
    cacheLevel?: CacheLevel;
    /**
     * The file path to store the cache to when the cache level is persistent.
     */
    cachePath?: string;
    /**
     * The maximum numbers of CPU cores to use.
     * @default: All available CPU cores.
     */
    coreCount?: number;
}

declare function squooshPlugin(options?: ModuleOptions): Plugin;

export { squooshPlugin as default };
